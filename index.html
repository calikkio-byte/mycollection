<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>MY COLLECTION — Mobile First (IndexedDB photos, Migratore)</title>
<style>
/* ... (stili invariati) ... */
</style>
</head>
<body>
  <!-- ... contenuto invariato ... -->
  <footer>
    Creato con ❤ — mobile first, funziona offline, dati nel tuo smartphone.<br>
    <strong>Realizzato da 2M Digital Consulting SRLS</strong>
  </footer>
<script>
// ===== Helpers base =====
const fmt = new Intl.NumberFormat('it-IT', {style:'currency', currency:'EUR'});
const q = sel => document.querySelector(sel);
const el = (tag, props={}, ...children)=>{ const n=document.createElement(tag); Object.assign(n, props); children.forEach(c=> n.append(c)); return n };
const parseNum = (v)=>{ if(!v) return 0; return parseFloat((''+v).replace(/\./g,'').replace(',', '.')) || 0 };
const uid = ()=>Math.random().toString(36).slice(2,9);

// ===== Keys =====
const KEY_V1 = 'mc_collection_data_v1'; // vecchia versione con foto in localStorage
const KEY_V2 = 'mc_collection_data_v2'; // nuova versione

// ===== Storage v2 =====
function load(){
  try{ return JSON.parse(localStorage.getItem(KEY_V2)) || { owner:'', cats:[], subs:{}, items:[] } }catch{ return { owner:'', cats:[], subs:{}, items:[] } }
}
function save(state){ localStorage.setItem(KEY_V2, JSON.stringify(state)) }
let state = null;

// ===== IndexedDB =====
const DB_NAME = 'mc_collection_db';
const DB_VER = 1;
let dbPromise = null;
function openDB(){
  if(dbPromise) return dbPromise;
  dbPromise = new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = ()=>{
      const db = req.result;
      if(!db.objectStoreNames.contains('photos')) db.createObjectStore('photos',{keyPath:'id',autoIncrement:true});
    };
    req.onsuccess = ()=> resolve(req.result);
    req.onerror = ()=> reject(req.error);
  });
  return dbPromise;
}
async function putPhoto(blob){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction('photos','readwrite');
    const req = tx.objectStore('photos').add({blob,created:Date.now()});
    req.onsuccess = ()=> res(req.result);
    req.onerror = ()=> rej(req.error);
  });
}
async function getPhoto(id){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction('photos','readonly');
    const req = tx.objectStore('photos').get(id);
    req.onsuccess = ()=> res(req.result||null);
    req.onerror = ()=> rej(req.error);
  });
}
async function deletePhoto(id){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction('photos','readwrite');
    const req = tx.objectStore('photos').delete(id);
    req.onsuccess = ()=> res();
    req.onerror = ()=> rej(req.error);
  });
}

// ===== Migratore v1 → v2 =====
async function migrateIfNeeded(){
  if(localStorage.getItem(KEY_V2)) return; // già migrato
  const old = localStorage.getItem(KEY_V1);
  if(!old) return;
  try{
    const data = JSON.parse(old);
    if(!data.items) return;
    const newState = { owner:data.owner||'', cats:data.cats||[], subs:data.subs||{}, items:[] };
    for(const it of data.items){
      const newItem = {...it, photoId:null};
      if(it.photo){
        try{
          const blob = await (await fetch(it.photo)).blob();
          newItem.photoId = await putPhoto(blob);
        }catch(err){ console.warn('Foto non migrata',err); }
      }
      delete newItem.photo;
      newState.items.push(newItem);
    }
    localStorage.setItem(KEY_V2, JSON.stringify(newState));
    state = newState;
    alert('✅ Migrazione completata: i tuoi dati e le foto sono stati aggiornati al nuovo formato.');
  }catch(err){ console.error('Migrazione fallita',err); }
}

// ===== Init =====
(async ()=>{
  await migrateIfNeeded();
  state = load();
  hydrate();
})();

// ===== Qui segue tutto il resto del codice (render, form, export, ecc.) invariato =====
// ===== Migration v1 (localStorage with DataURL photos) -> v2 (IndexedDB photos) =====
async function migrateIfNeeded(){
  const V1KEY = 'mc_collection_data_v1';
  const migratedFlag = 'mc_collection_migrated_to_v2';
  if(localStorage.getItem(migratedFlag)) return; // già migrato
  const raw = localStorage.getItem(V1KEY);
  if(!raw) return; // non esiste v1
  let old;
  try{ old = JSON.parse(raw) }catch{ return }
  if(!old || !Array.isArray(old.items) || old.items.length===0) { localStorage.setItem(migratedFlag,'1'); return }

  // Se non ci sono foto DataURL, migra solo struttura
  const hasPhotos = old.items.some(i=> i && typeof i.photo === 'string' && i.photo.startsWith('data:image'));
  const newState = { owner: old.owner||'', cats: old.cats||[], subs: old.subs||{}, items: [] };

  for(const i of old.items){
    const ni = {
      id: i.id || Math.random().toString(36).slice(2,9),
      category: i.category||'',
      subcategory: i.subcategory||'',
      name: i.name||'',
      description: i.description||'',
      date: i.date||'',
      place: i.place||'',
      price: i.price||0,
      estimate: i.estimate||0,
      photoId: null
    };
    if(hasPhotos && i.photo && typeof i.photo==='string' && i.photo.startsWith('data:image')){
      try{
        const blob = await (await fetch(i.photo)).blob();
        const pid = await putPhoto(blob);
        ni.photoId = pid;
      }catch(err){ console.warn('Foto non migrata per item', i.name, err); }
    }
    newState.items.push(ni);
  }
  // salva in v2 e marca migrato
  try{ localStorage.setItem(KEY, JSON.stringify(newState)); state = newState; }catch(err){ console.error('Salvataggio v2 fallito', err) }
  localStorage.setItem(migratedFlag,'1');
  // opzionale: rimuovi la chiave v1 (manteniamo per sicurezza, ma possiamo pulire)
  // localStorage.removeItem(V1KEY);
  // Feedback utente
  try{ alert('Migrazione completata: dati spostati alla versione v2 con foto in IndexedDB.'); }catch{}
}

// Start
(async ()=>{ await migrateIfNeeded(); hydrate(); })();
</script>
</body>
</html>
